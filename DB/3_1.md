# **SSAFY DB SQL 03: 고급 조회 (Subqueries, Set Operations & Window Functions)**

이 문서는 여러 테이블의 데이터를 결합하거나, 쿼리 내에 하위 쿼리를 사용하고, 복잡한 분석을 수행하는 고급 SQL 조회 기법을 정리합니다.

## **1\. JOIN (복습)**

두 개 이상의 테이블을 공통된 키(FK)를 기준으로 연결하여 데이터를 조회하는 방법입니다.

* **INNER JOIN:** 두 테이블에 모두 존재하는, 조인 조건이 일치하는 행만 반환합니다. (교집합)  
* **LEFT JOIN:** 왼쪽 테이블(먼저 선언된 테이블)의 모든 행을 반환하며, 오른쪽 테이블에 일치하는 데이터가 없으면 NULL로 표시됩니다.

## **2\. 집합 연산자 (Set Operations)**

두 개 이상의 SELECT 문의 결과 집합을 결합하는 연산자입니다. **조건:** 두 SELECT 문의 열(column) 개수와 데이터 타입이 일치해야 합니다.

| 연산자 | 설명 | 중복 제거 |
| :---- | :---- | :---- |
| **UNION** | 두 결과 집합을 합칩니다. (합집합) | O (기본) |
| **UNION ALL** | 두 결과 집합을 합칩니다. **중복을 제거하지 않아** UNION보다 빠릅니다. | X |
| **INTERSECT** | 두 결과 집합에 **모두** 존재하는 행만 반환합니다. (교집합) | O |
| **EXCEPT** | 첫 번째 결과 집합에서 두 번째 결과 집합에 존재하는 행을 **제외**하고 반환합니다. (차집합) | O |

**예시:**

\-- users 테이블에서 '서울' 거주자와  
\-- customers 테이블에서 '서울' 거주자를 모두 합쳐서 조회 (중복 제거)  
SELECT name FROM users WHERE city \= '서울'  
UNION  
SELECT customer\_name FROM customers WHERE city \= '서울';

## **3\. 서브쿼리 (Subquery)**

하나의 SQL 쿼리 문 안에 포함된 또 다른 SELECT 쿼리 문입니다. "쿼리 안의 쿼리"라고 불립니다. 메인 쿼리가 실행되기 전에 서브쿼리가 먼저 실행되어, 그 결과를 메인 쿼리가 사용합니다.

### **3-1. WHERE 절의 서브쿼리**

가장 일반적인 형태로, WHERE 절의 조건문에서 서브쿼리의 결과를 사용합니다.

* **비교 연산자 (=, \>, \< 등):** 서브쿼리가 \*\*단일 값(Scalar)\*\*을 반환해야 합니다.  
  \-- '홍길동'의 나이보다 많은 사람들을 조회  
  SELECT \* FROM users  
  WHERE age \> (SELECT age FROM users WHERE name \= '홍길동');

* **IN / NOT IN:** 서브쿼리가 \*\*여러 개의 값(열)\*\*을 반환할 때 사용합니다.  
  \-- 'articles' 테이블에 게시글을 작성한 적이 있는 모든 유저의 정보를 조회  
  SELECT \* FROM users  
  WHERE id IN (SELECT userId FROM articles);

* **EXISTS / NOT EXISTS:** 서브쿼리의 결과가 존재하는지(최소 1행) 여부만 확인합니다.  
  \-- 게시글을 작성한 유저만 조회 (IN보다 성능이 좋을 수 있음)  
  SELECT \* FROM users  
  WHERE EXISTS (SELECT 1 FROM articles WHERE articles.userId \= users.id);

### **3-2. SELECT 절의 서브쿼리 (Scalar Subquery)**

SELECT 절에서 특정 필드 값처럼 사용됩니다. 반드시 \*\*단일 값(1행 1열)\*\*만 반환해야 합니다.

* **특징:** 메인 쿼리의 각 행마다 서브쿼리가 실행되므로, 상관관계(Correlated)가 있는 경우가 많습니다.

\-- 각 유저의 이름과 해당 유저가 작성한 게시글의 '총 개수'를 함께 조회  
SELECT  
    id,  
    name,  
    (SELECT COUNT(\*) FROM articles WHERE articles.userId \= users.id) AS article\_count  
FROM users;

### **3-3. FROM 절의 서브쿼리 (Inline View)**

FROM 절에서 서브쿼리의 결과 집합을 하나의 임시 테이블(View)처럼 사용합니다.

* **특징:** 서브쿼리의 결과 집합에 **반드시 별칭(Alias)을 지정**해야 합니다.  
* **활용:** GROUP BY로 집계된 결과에 대해 추가적인 필터링이나 조인을 할 때 유용합니다.

\-- 각 유저별 게시글 수를 계산한 임시 테이블(T1)을 만들고,  
\-- 그 중에서 게시글 수가 10개 이상인 유저만 조회  
SELECT T1.name, T1.article\_count  
FROM (  
    SELECT userId, COUNT(\*) AS article\_count  
    FROM articles  
    GROUP BY userId  
) AS T1\_Stats  
INNER JOIN users AS U  
ON U.id \= T1\_Stats.userId  
WHERE T1\_Stats.article\_count \>= 10;

## **4\. 윈도우 함수 (Window Functions)**

GROUP BY처럼 행을 그룹화하여 집계하지만, GROUP BY와 달리 **결과 행을 축소하지 않고** 각 행에 대한 집계 값을 계산하여 새로운 열로 추가합니다.

### **핵심 문법**

FUNCTION() OVER (PARTITION BY ... ORDER BY ...)

* **PARTITION BY**: 데이터를 나눌 그룹(파티션)을 지정합니다. ( GROUP BY와 유사 )  
* **ORDER BY**: 파티션 내에서 순서를 정합니다. (순위, 누적 계산 시 필수)

### **1\. 순위 함수 (Ranking Functions)**

| 함수 | 설명 | 예시 (점수: 100, 90, 90, 80\) |
| :---- | :---- | :---- |
| **ROW\_NUMBER()** | 파티션 내에서 고유한 순번을 매깁니다. (중복 없음) | 1, 2, 3, 4 |
| **RANK()** | 순위를 매깁니다. 공동 순위가 있으면 다음 순위를 건너뜁니다. | 1, 2, 2, **4** |
| **DENSE\_RANK()** | 순위를 매깁니다. 공동 순위가 있어도 다음 순위를 건너뛰지 않습니다. | 1, 2, 2, **3** |

### **2\. 집계 함수 (Aggregate Functions)**

COUNT, SUM, AVG, MAX, MIN 등도 OVER 절과 함께 윈도우 함수로 사용될 수 있습니다.

**예시 1: 순위 매기기**

\-- 직원들의 급여를 기준으로 순위를 매김  
SELECT  
    name,  
    salary,  
    ROW\_NUMBER() OVER (ORDER BY salary DESC) AS row\_num,  
    RANK() OVER (ORDER BY salary DESC) AS rank\_num,  
    DENSE\_RANK() OVER (ORDER BY salary DESC) AS dense\_rank\_num  
FROM employees;

**예시 2: 그룹 내 집계 (PARTITION BY)**

\-- 각 부서(department)별 평균 급여를 '모든' 직원 행에 함께 표시  
SELECT  
    name,  
    department,  
    salary,  
    AVG(salary) OVER (PARTITION BY department) AS department\_avg\_salary  
FROM employees;

| name | department | salary | department\_avg\_salary |
| :---- | :---- | :---- | :---- |
| 김철수 | 영업 | 5000 | 5500 |
| 이영희 | 영업 | 6000 | 5500 |
| 박대리 | 개발 | 7000 | 7250 |
| 최주임 | 개발 | 7500 | 7250 |

## **5\. 기타 참고**

### **1\. 데이터 타입 (Data Types \- SQLite 기준)**

| 타입 | 설명 |
| :---- | :---- |
| **INTEGER** | 정수 (1, 2, 3\) |
| **REAL** | 실수 (1.2, 3.14) |
| **TEXT** | 문자열 ('Hello') |
| **NUMERIC** | 숫자 (정수, 실수, 날짜/시간 등) |
| **BLOB** | 바이너리 데이터 (이미지, 오디오 파일 등) |

* **타입 선호도 (Type Affinity):** SQLite는 타입을 엄격하게 강제하지 않습니다. INTEGER 필드에 TEXT를 넣어도 저장은 되지만, 내부적으로 INTEGER로 변환하려 시도합니다.

### **2\. 집계 함수 (Aggregate Functions \- 복습)**

GROUP BY 또는 윈도우 함수와 함께 사용되어 여러 행의 값을 요약합니다.

* COUNT(): 행의 개수  
* SUM(): 합계  
* AVG(): 평균  
* MAX(): 최댓값  
* MIN(): 최솟값