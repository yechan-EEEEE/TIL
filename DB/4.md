# **SSAFY Django Many-To-One 관계 및 인증 기반 CRUD 구현**

이 문서는 Django에서 **일대다(Many-To-One) 관계**를 설정하고, 로그인한 사용자(User)를 기반으로 **게시글 및 댓글 CRUD**를 구현하며, **View Decorator**를 활용하여 접근을 제어하는 방법을 정리합니다.

## **1\. 일대다(M:N) 관계 설정: Article ↔ User**

하나의 사용자는 여러 개의 게시글을 작성할 수 있고, 하나의 게시글은 한 명의 작성자에 의해 작성됩니다.

### **1-1. Article Model 수정 (articles/models.py)**

Article 모델에 작성자를 연결하기 위한 **외래 키(Foreign Key)** 필드를 추가합니다.

* settings.AUTH\_USER\_MODEL: Django가 사용하는 **실제 User 모델**을 참조할 때 사용하는 문자열입니다. 순환 참조 문제를 피하기 위해 직접 User 모델을 import하는 대신 이 문자열을 사용하는 것이 일반적입니다.

```
articles/models.py

from django.db import models  
from django.conf import settings \# settings.AUTH\_USER\_MODEL 사용을 위해 import

class Article(models.Model):  
    user \= models.ForeignKey(  
        settings.AUTH\_USER\_MODEL,    \# 사용자 모델 참조 (일대다 관계 설정)  
        on\_delete=models.CASCADE     \# User가 삭제되면 작성한 Article도 함께 삭제  
    )  
    title \= models.CharField(max\_length=10)  
    content \= models.TextField()  
    created\_at \= models.DateTimeField(auto\_now\_add=True)  
    updated\_at \= models.DateTimeField(auto\_now=True)

    def \_\_str\_\_(self):  
        return self.title

\# User 모델에 접근하는 2가지 방법  
\# 1\. settings.AUTH\_USER\_MODEL (문자열) : ForeignKey 설정 시 사용  
\# 2\. get\_user\_model() (함수) : Python 코드 상에서 실제 User 객체를 가져올 때 사용
```
### **1-2. 게시글 생성 로직 수정 (CREATE)**

게시글 생성 시, 사용자가 직접 작성자를 선택하는 것이 아니라 **현재 로그인된 사용자**를 자동으로 저장해야 합니다.

* form.save(commit=False): DB에 저장하지 않고 객체만 생성하여 반환합니다.

```
\# articles/views.py (create 함수)

from django.shortcuts import render, redirect

@login\_required \# 로그인 필수 데코레이터 (아래 3절 참고)  
def create(request):  
    if request.method \== 'POST':  
        form \= ArticleForm(request.POST)  
        if form.is\_valid():  
            article \= form.save(commit=False) \# 1\. 임시 저장 (user 필드가 비어있음)  
            article.user \= request.user       \# 2\. 현재 로그인 사용자(request.user)를 할당  
            article.save()                    \# 3\. 최종 저장  
            return redirect('articles:detail', article.pk)  
    else:  
        form \= ArticleForm()  
    context \= {  
        'form': form,  
    }  
    return render(request, 'articles/create.html', context)
```
## **2\. 권한 기반 게시글 CRUD 구현**

게시글 수정/삭제 시 **작성자 본인**만 접근하도록 권한을 확인하는 로직이 필요합니다.

### **2-1. 게시글 수정 (UPDATE)**

게시글 조회 후, 현재 로그인된 사용자와 게시글의 작성자가 동일한지 확인합니다.

```
\# articles/views.py (update 함수)

@login\_required  
def update(request, pk):  
    article \= Article.objects.get(pk=pk)

    \# 요청 사용자 \== 게시글 작성자 인지 확인 (권한 체크)  
    if request.user \== article.user:   
        if request.method \== 'POST':  
            form \= ArticleForm(request.POST, instance=article)  
            if form.is\_valid():  
                form.save()  
                return redirect('articles:detail', article.pk)  
        else:  
            form \= ArticleForm(instance=article)  
    else:  
        \# 권한이 없는 경우, 상세 페이지로 돌려보냄  
        return redirect('articles:detail', article.pk)

    context \= {  
        'article': article,  
        'form': form,  
    }  
    return render(request, 'articles/update.html', context)
```
### **2-2. 게시글 삭제 (DELETE)**

삭제 요청 시에도 수정과 동일하게 작성자 본인 여부를 확인합니다.
```
\# articles/views.py (delete 함수)

@login\_required  
def delete(request, pk):  
    article \= Article.objects.get(pk=pk)

    \# 요청 사용자 \== 게시글 작성자 인지 확인 (권한 체크)  
    if request.user \== article.user:  
        article.delete()  
        return redirect('articles:index')  
      
    \# 권한이 없는 경우 상세 페이지로 리다이렉트 (삭제 방지)  
    return redirect('articles:detail', article.pk)
```
## **3\. 댓글 CRUD 구현: Comment ↔ Article & User**

댓글은 게시글(Article)과 사용자(User) 모두와 일대다 관계를 가집니다.

### **3-1. Comment Model 설계 (articles/models.py)**

댓글 모델은 게시글(article)과 작성자(user) 모두를 외래 키로 참조합니다.
```
\# articles/models.py (Comment Model 추가)

class Comment(models.Model):  
    \# 1\. Article과의 일대다 관계 (어떤 글의 댓글인지)  
    article \= models.ForeignKey(Article, on\_delete=models.CASCADE)  
      
    \# 2\. User와의 일대다 관계 (누가 작성했는지)  
    user \= models.ForeignKey(settings.AUTH\_USER\_MODEL, on\_delete=models.CASCADE)  
      
    content \= models.CharField(max\_length=200)  
    created\_at \= models.DateTimeField(auto\_now\_add=True)  
    updated\_at \= models.DateTimeField(auto\_now=True)

    def \_\_str\_\_(self):  
        return self.content
```
### **3-2. 댓글 생성 (CREATE)**

댓글은 주로 게시글 상세 페이지에서 생성되므로, URL에서 article\_pk를 받습니다.
```
\# articles/views.py (comments\_create 함수)

@login\_required  
def comments\_create(request, pk):  
    article \= Article.objects.get(pk=pk)  
    comment\_form \= CommentForm(request.POST)

    if comment\_form.is\_valid():  
        comment \= comment\_form.save(commit=False)  
        comment.article \= article    \# 외래 키 1: 게시글 정보 할당  
        comment.user \= request.user  \# 외래 키 2: 사용자 정보 할당  
        comment.save()  
        return redirect('articles:detail', article.pk)  
      
    \# 유효성 검사 실패 시 (실패 시에도 상세 페이지로 돌아가 오류 메시지를 표시)  
    context \= {  
        'article': article,  
        'comment\_form': comment\_form,  
    }  
    return render(request, 'articles/detail.html', context)
```
### **3-3. 댓글 삭제 (DELETE)**

댓글 역시 작성자 본인만 삭제 가능하도록 권한을 확인합니다.
```
\# articles/views.py (comments\_delete 함수)

@login\_required  
def comments\_delete(request, article\_pk, comment\_pk):  
    comment \= Comment.objects.get(pk=comment\_pk)  
      
    \# 요청 사용자 \== 댓글 작성자 인지 확인 (권한 체크)  
    if request.user \== comment.user:  
        comment.delete()  
      
    return redirect('articles:detail', article\_pk)
```
### **3-4. 템플릿에 작성자 및 삭제 버튼 표시**

Article이나 Comment 객체의 user 필드를 사용하여 작성자의 정보를 표시하고, 현재 로그인된 사용자와 비교하여 삭제 버튼을 노출합니다.
```
\<\!-- articles/detail.html (댓글 목록 부분) \--\>

\<h3\>댓글 목록\</h3\>  
\<ul\>  
{% for comment in article.comment\_set.all %}   
    \<li\>  
        \<\!-- 댓글 작성자 이름 출력 \--\>  
        작성자: {{ comment.user.username }} | 내용: {{ comment.content }}  
          
        \<\!-- 현재 로그인 사용자와 댓글 작성자가 동일한 경우에만 삭제 버튼 노출 \--\>  
        {% if request.user \== comment.user %}  
            \<form action="{% url 'articles:comments\_delete' article.pk comment.pk %}" method="POST" style="display: inline;"\>  
                {% csrf\_token %}  
                \<input type="submit" value="DELETE"\>  
            \</form\>  
        {% endif %}  
    \</li\>  
{% endfor %}  
\</ul\>
```
## **4\. View Decorator (@login\_required, @require\_http\_methods)**

View Decorator는 View 함수가 실행되기 전에 조건을 검사하거나 추가 기능을 수행할 때 사용됩니다.

### **4-1. @login\_required**

* **기능:** View 함수를 실행하기 전에 **로그인 여부**를 확인합니다.  
* **효과:** 로그인하지 않은 사용자가 접근하면 settings.LOGIN\_URL로 지정된 로그인 페이지로 리다이렉트됩니다. (예: accounts:login)
```
\# 사용 예시  
from django.contrib.auth.decorators import login\_required

@login\_required  
def create(request):  
    \# ... 로그인한 사용자만 이 코드를 실행할 수 있음  
    pass
```
### **4-2. @require\_http\_methods**

* **기능:** View 함수가 허용하는 **HTTP 요청 메서드**를 지정합니다.  
* **효과:** 허용되지 않은 메서드로 요청이 오면 **405 Method Not Allowed** 응답을 반환합니다.
```
\# 사용 예시  
from django.views.decorators.http import require\_http\_methods

@require\_http\_methods(\['GET', 'POST'\])  
def update(request, pk):  
    \# ... GET 또는 POST 요청만 허용  
    pass
```
## **5\. ERD (Entity Relationship Diagram)의 이해**

데이터베이스의 개체(Entity)와 개체 간의 관계(Relationship)를 시각적으로 표현한 다이어그램입니다.

### **5-1. ERD 구성 요소**

| 요소 | 설명 | 예시 |
| :---- | :---- | :---- |
| **개체(Entity)** | 저장하려는 대상 (테이블에 해당) | User, Article, Comment |
| **속성(Attribute)** | 개체가 가진 특징 (컬럼/필드에 해당) | User의 id, name, address |
| **관계(Relationship)** | 개체 간의 상호작용 (외래 키/조인에 해당) | User는 Article을 **작성한다** |

### **5-2. 다중성 (Cardinality)**

개체 간의 관계에서 참여하는 개체의 수적 비율을 나타냅니다.

| 관계 | 설명 | Django 외래 키 설정 |
| :---- | :---- | :---- |
| **One-to-One (1:1)** | 각 개체가 상대방 개체의 레코드 하나와만 연결 | OneToOneField |
| **One-to-Many (1:N)** | 한 개체가 여러 개의 상대방 개체와 연결 (본 영상 주제) | ForeignKey |
| **Many-to-Many (N:M)** | 양쪽 모두 여러 개의 상대방 개체와 연결 | ManyToManyField |

## **6\. 핵심 키워드 정리 (복습)**

| 개념 | 설명 | 예시 |
| :---- | :---- | :---- |
| **settings.AUTH\_USER\_MODEL** | Django 프로젝트가 사용하는 User 모델을 참조하는 문자열 (순환 참조 방지) | models.ForeignKey(settings.AUTH\_USER\_MODEL, ...) |
| **역참조 (Reverse Relation)** | 외래 키를 가지지 않은 쪽(User)에서 외래 키를 가진 쪽(Article)을 조회하는 것 | user.article\_set.all() |
| **@login\_required** | View 함수가 실행되기 전에 사용자 인증 여부를 확인하는 데코레이터 | views.py에서 인증 여부 체크 |
| **권한 확인** | CRUD 작업 시, 현재 사용자(request.user)가 해당 객체(article.user)의 작성자인지 확인하는 로직 | if request.user \== article.user: |

