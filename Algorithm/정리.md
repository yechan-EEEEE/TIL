# BST(이진 탐색 트리)
## 특징
- 각 노드는 자식을 최대 2개를 가질 수 있음, 순서속성을 가짐
- 순서속성이란, 왼쪽 자식 노드의 키 값은 부모 노드의 키 값보다 작음. 오른쪽 자식 노드는 부모 노드보다 큼

## 장점
- 삽입/삭제 후에도 정렬된 상태 유지, 데이터가 균형있게 분포되어 있을 때, 시간 복잡도 O(logN), 동적으로 크기조정가능

## 단점
- 불균형하게 있을 때 시간복잡도는 O(n)이 될 수 있음
- 큰 데이터의 집합일 경우 메모리 오버헤드가 발생 할 수 있음

## 속성
- 높이 -> 특정 노드에서 가장 깊은 리프 노드까지의 경로에 있는 간선 개수
- 트리의 높이는 루트 노드의 높이와 동일
- 리프 노드의 높이는 0
- 균형잡힌 트리의 높이는 O(logN) 불균형인 트리의 높이는 O(n)
- 깊이 -> 루트 노드에서 해당 노드까지의 경로에 있는 간선 개수
- 루트 노드의 깊이는 0

## 탐색
- 순서속성을 이용하여 키 값을 비교

## 삽입
- 삽입할 위치를 찾기 위해 루트 노드에서부터 적절한 위치까지 내려감
- 새로운 노드는 리프노드로 삽입

## 삭제
- 자식노드의 유무로 판별
    - 리프 노드일 경우 -> 단순 제거
    - 한 개의 자식 노드일 경우 -> 삭제할 노드의 자식노드를 부모노드에 연결
    - 두 개의 자식 노드일 경우 -> 중위 후속자 또는 중위 전임자 찾음
        - 중위 후속자 : 삭제할 노드의 오른쪽 자식 노드에서 제일 작은 값
        - 중위 전임자 : 삭제할 노드의 왼쪽 자식 노드에서 제일 큰 값

## 정리
- 탐색 작업을 효율적으로 하기 위한 자료구조 평균 O(logN)
- key(왼쪽 서브트리) < key(루트 노드) < key(오른쪽 서브트리)
- 왼쪽과 오른쪽 서브트리도 이진탐색트리
- 중위순회를 하면 오름차순으로 결과를 얻음

## 문제사항
- 구조는 순서에 따라 결정되기 때문에 특정 패턴으로 삽입 경우 불균형 발생
- 불균형 발생시 시간 복잡도는 O(N)이 됨
- 트리의 높이가 증가하면서 많은 메모리 필요, 스택 오버플로우 문제 발생 가능

--------------------------------------------------------------------------
# 힙(heap)
## 특징
- 키 값이 가장 작거나, 큰 값을 얻기 위한 자료구조
- 최소 힙(min heap)
- 최대 힙(max heap)
    - 키 값이 가장 큰 노드를 얻기위한 완전 이진 트리
    - 부모 노드의 키값 > 자식 노드의 키 값
    - 루트노드 == 가장 키 값이 큰 노드

## 삽입
- 새로운 원소를 마지막 위치에 추가
- 부모 노드와 비교하며 속성을 만족 할 때 까지 위로 올림
- 최선 : O(1)
- 평균/최악 : O(logN)

## 삭제
- 루트 노드 제거, 마지막 요소를 루트로 선언
- 새 루트를 자식들과 비교, 속성을 만족할 때까지 내린다
- 최선 : O(1)
- 평균/최악 : O(logN)

## heap 모듈
- 최소 힙을 구하기 위한 라이브러리
- 함수 활용
    - heapq.heapify(x) : 리스트x를 heap으로 변환 O(n)
    - heapq.heappush(heap, item) : item을 heap에 추가
    - heapq.heappop(heap) : heap에서 가장 작은 원소를 pop하고 리턴

## 최대힙 구현
- 모든 값을 음수로 변환해서 사용

## 우선순위 큐
- 우선순위를 원소로 활용, 최대 힙을 사용하면 우선순위 요소가 먼저 나오도록 구현
- 노드 하나 추가/삭제 시간복잡도가 O(logN), 최대값/최소값을 O(1)에 구함

--------------------------------------------------------------------------
# 분할정복
- 복잡한 문제를 더 작은 하위 문제들로 나누어 해결하는 알고리즘
- 분할 : 해결할 문제를 여러 개의 작은 부분으로 나눔
- 정복 : 나눈 작은 문제를 각각 해결
- 통합 : 해결된 해답을 모은다
- 분할정복에는 밑에 3가지 있음(이진탐색,병합정렬,퀵정렬)

--------------------------------------------------------------------------
# 이진탐색
- 가운데에 있는 항목의 키 값과 비교하여 다음 검색의 위치를 결정하고 검색을 진행하는 방법
- 자료가 정렬된 상태여야함

## 이진탐색 과정
1. 자료의 중앙에 있는 원소 선택
2. 중앙 원소 값과 찾고자 하는 목표 값 비교
3. 작으면 왼쪽 반에 대해서 새로 검색, 크다면 오른쪽 반에 대해서 새로 검색
4. 찾고자 하는 값을 찾을 떄까지 반복
- 반복구조가 있고, 재귀구조가 있음

--------------------------------------------------------------------------
# 정렬(병합정렬 AND 퀵 정렬)

## 병합정렬
- 여러 개의 정렬된 자료의 집합을 병합하여, 한 개의 정렬된 집합으로 만드는 방식

## 병합정렬의 과정
1. 주어진 배열을 같은 크기의 두 부분의 배열로 나눔(재귀적으로 반복, 나눌 수 없을 떄까지)
2. 나눠진 두 부분 배열을 하나의 정렬된 배열로 병합
3. 위 과정을 재귀적으로 반복하여 전체 배열이 정렬될 떄까지 반복
- **시간 복잡도 : O(nlogn)**

## 병합정렬 정리
1. 큰 데이터셋을 정렬할 때 유용, 안정적, 예측 가능한 성능 제공
2. 최선/최악 시간복잡도 : O(nlogn)
3. 안정성 : O
4. 적응성 : X
5. 제자리 정렬 : X
----------------------------
## 퀵 정렬
- 주어진 리스트를 두 개로 분할 , 각각 정렬
- **기준 아이템(pivot item)**을 중심으로 작으면 왼쪽, 크면 오른쪽에 위치

## 퀵 정렬의 과정
1. 리스트에서 하나의 요소를 피벗으로 선택
2. 피벗보다 작으면 왼쪽, 크면 오른쪽으로 이동
3. 최종위치에 놓인 피벗을 기준으로 왼/오른쪽 부분 배열에 퀵 정렬을 재귀적으로 수행
4. 부분 배열 크기가 1이하가 되면 재귀 종료
- **시간 복잡도 : O(nlogn)**

## 퀵 정렬 정리
1. 평균적으로 매우 빠름, 메모리 효율 좋음
2. 최악 시간복잡도 : O(n<sup>2</sup>)
3. 최선 시간복잡도 : O(nlogn)
4. 안정성 : X
5. 적응성 : O
6. 제자리 정렬 : O

--------------------------------------------------------------------------
# 메모이제이션 AND DP

## 메모이제이션(memorization)
- 메모리에 저장해서 다시 계산 하지 않도록 하는 기술
- **동적 계획법(Dynamic Programming)**의 핵심 기술
- 탑 다운 접근방식
- 추가적인 메모리 공간 필요
- 재귀 함수 호출로 인한 시스템 호출 스택을 사용, 실행 속도 저하 또는 오버플로우 발생 가능

## DP(Dynamic Programming)
- 그리디 알고리즘과 같이 최적화 문제를 해결하는 알고리즘
- 작은 부분 문제들을 해결한 후 그 해를 활용하여 큰 크기의 부분 문제를 해결하여, 최종적으로 주어진 입력의 문제를 해결하는 알고리즘

## 적용 요건
- 중복 부분문제 구조
    - 점화식 사용
    - 이미 해결된 작은 문제의 답은 table에 저장
    - table을 참조 해서 중복된 계산 피하게 됨
- 최적 부분문제 구조
    - 문제에 대한 해가 최적일 때 그 해가 구성하는 작은 문제들의 해 역시 최적
    - 적용이 안되는 문제 : 최장경로문제
--------------------------------
## 분할 정복과 동적 계획법의 차이
- 분할 정복
    - 연관 없는 부분 문제로 분할
    - 재귀적으로 해결
    - 부분문제 답을 결합
    - 병합 정렬, 퀵 정렬
- DP
    - 부분 문제들이 연관이 없으면 적용 안 됨
    - 부분 문제를 한 번 계산하고 결과 저장하고 재사용

- 정리
    - DP에는 부분 문제들 사이에 의존적 관계 존재
    - 대부분의 경우 뚜렷이 보이지 않아서 **함축적인 순서**라고 함
    - 분할 정복은 **하향식 방법**, DP는 **상향식 방법**으로 접근

--------------------------------------------------------------------------
# 피보나치 수 DP 적용 
1. 문제를 부분 문제로 분할
2. 점화식 정의
3. 가장 작은 문제 답 구하고, 테이블 저장, 저장된 답을 활용하여 상위 문제의 답 구함

## 피보나치 수 DP 정리
- DP 알고리즘이 재귀보다 수행속도가 더 빠름
    - 재귀와 달리 중복이 없음
    - 반복문을 사용해서 함수 호출 발생 안함
- 계산하는 항의 개수
    - T(n) = n+1
    - 0~n 까지 단 한번씩만 계산