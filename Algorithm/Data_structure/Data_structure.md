# 스택
- 물건을 쌓듯이 자료를 쌓아올린 형태의 자료구조
- 스택은 선형 구조
    - 선형 구조: 자료간의 관계가 1대1의 관계, 순서가 있다
    - 비선형 구조: 자료간의 관계 1대N의 관계
- 스택에서 자료를 삽입하거나 스택에서 자료를 꺼낼 수 있다
- 뒤로 가기나 함수 호출에서 사용되는 자료구조
- 후입 선출 구조(LIFO,Last-In First_Out)
    - 마지막에 삽입한 자료를 가장 먼저 꺼낸다
## 스택의 연산
- push: 저장소에 자료를 저장,append
- pop: 저장소에서 자료를 꺼낸다, 꺼낸 자료는 자료의 역순으로 꺼낸다(후입선출)
- IsEmpty: 스택이 공백인지 확인
- Peek: top(가장 마지막에 들어간 자료)에 있는 자료를 반환
## 스택 응용
- 괄호 검사
    - 여는 괄호,닫는 괄호 개수 같기
    - 여는 괄호가 먼저 나오기
    - 괄호 짝이 맞기
      수까지 세라하기 문제 내기 좋다?
# 스택 2
- 8페이지 3-1 우선순위:토큰>스택
## 계산기(중위/후위  표기법)
- 스택을 이용해서 중위 표기법을 후위 표기법으로 변경
    1. 연산자의 우선 순위에 따라 괄호로 표현
    2. 각 연산자를 대응하는 오른쪽 괄호의 뒤로 이동
    3. 괄호 제거

- 중위 표기법 > 후위 표기법 변환 알고리즘
    1. 중위 표기식에서 토큰을 하나씩 읽는다.
    2. 토큰이 피연산자이면 토큰을 출력한다.
    3. 토큰이 연산자일 때
        1. 우선순위: 토큰>스택의 top 이면 스택에 push
        2. 우선순위: 토큰<=스택의 top 이면 스택에 있는 다음 연산자가 우선순위가 작을 때까지 pop 하고 push
        3. top에 연산자가 없다(스택에 연산자가 없으면) 바로 스택에 push
    4. 토큰이 닫는 괄호('),},]')면 스택 top 에 여는 괄호가 올 때까지 pop 하고 출력 여는 괄호 만나면 pop 출력X
    5. 표기식에 남은 토큰이 있으면 다시 반복, 없으면 그만
    6. 스택에 남아있는 연산자를 모두 pop 해서 출력
       ex)(6+5*(2-8)/2)
       ((6+5)*(28-)/2)
       ((6+5)(28-*)/2)
       ((6+5)(28-*2/))
       (6528-*2/+)
       6528-*2/+

234*5/+
2+3*4+5
2+34*+5
234*+
234*+5+
연산자 나오면 스택에 저장, 스택에 있는 연산자 우선순위 or 같으면 꺼내고 우선순위가 낮은 애를 집어넣기



3+(2*5)-8/4
3+25*-84/
(325*+)-84/
325*+84/-
# 재귀 호출
재귀함수 기본부분>종료조건 유도부분>작아지는 부분
## 팩토리얼
## 피보나치 수열

# 큐(queue)
## 구조와 작동원리
- 스택과 마찬가지로 삽입과 삭제의 위치가 제한적인 자료구조
    - 큐는 뒤에서만 삽입 앞에서는 삭제만
- 선입선출(FIFO,First In First Out)
## 주요 연산
- EnQueue
  - 큐의 뒤쪽에 원소 삽입
- DeQueue
  - 큐의 앞쪽에서 원소 삭제하고 반환
- IsEmpty
  - 공백인지 확인
- IsFull
  - 포화상태인지 확인
- peek
  - 앞쪽에서 원소를 삭제하지 않고 반환
- createQueue
  - 공백 큐 생성
## 응용
- 버퍼
- 마이쮸우ㅜㅜ우ㅜ우ㅜㅜ
## 원형큐
## pop 대신
from collections import deque 진짜 많이 쓰임 queue.popleft rotate

## 연결 리스트
# 리스트의 문제점
- 자료의 삽입/삭제 연산 과정에서 원소들을 이동시키는 작업이 필요하다
- 원소의 개수가 많고 삽입/삭제 연산이 빈번하게 일어날수록 소요되는 시간이 크다
## 연결 리스트

#from collections import dequeue     