N*N 크기의 도시에 홈방범 서비스를 제공하려고 한다.
마름모 모양의 영역에서만 제공된다.
운영 비용이 필요하다.
서비스 영역의 크기 K 가 커질수록 운영 비용이 커진다.
운영 비용은 서비스 영역의 면적과 동일하며, 아래와 같이 구할 수 있다.
운영 비용 = K * K + (K - 1) * (K - 1)
운영 영역의 크기 K 는 1 이상의 정수이다.
도시를 벗어난 영역에 서비스를 제공해도 운영 비용은 변경되지 않는다.
홈방범 서비스를 제공받는 집들은 각각 M의 비용을 지불,
손해를 보지 않는 한 최대한 많은 집에 홈방범 서비스를 제공.
도시의 크기 N과 하나의 집이 지불할 수 있는 비용 M, 도시의 정보가 주어진다.
손해를 보지 않으면서 홈방범 서비스를 가장 많은 집들에 제공하는 서비스 영역을 찾고,
그 때의 홈방범 서비스를 제공 받는 집들의 수를 출력하는 프로그램을 작성하라.

[제약사항]
1. 시간제한 : 최대 50개 테스트 케이스를 모두 통과하는데, C/C++/Java 모두 3초
2. 도시의 크기 N은 5 이상 20 이하의 정수이다. (5 ≤ N ≤ 20)
3. 하나의 집이 지불할 수 있는 비용 M은 1 이상 10 이하의 정수이다. (1 ≤ M ≤ 10)
4. 홈방범 서비스의 운영 비용은 서비스 영역의 면적과 동일하다.
5. 도시의 정보에서 집이 있는 위치는 1이고, 나머지는 0이다.
6. 도시에는 최소 1개 이상의 집이 존재한다.

[입력]
입력의 맨 첫 줄에는 총 테스트 케이스의 개수 T가 주어지고, 그 다음 줄부터 T개의 테스트 케이스가 주어진다.
각 테스트 케이스의 첫 번째 줄에는 도시의 크기 N과 하나의 집이 지불할 수 있는 비용 M이 주어진다.
그 다음 줄부터 N*N 크기의 도시정보가 주어진다. 지도에서 1은 집이 위치한 곳이고, 나머지는 0이다.

[출력]
테스트 케이스의 개수만큼 T줄에 T개의 테스트 케이스 각각에 대한 답을 출력한다.
각 줄은 "#x"로 시작하고 공백을 하나 둔 다음 정답을 출력한다. (x는 1부터 시작하는 테스트 케이스의 번호이다)
출력해야 할 정답은 손해를 보지 않으면서 홈방범 서비스를 가장 많은 집들에 제공하는 서비스 영역을 찾았을 때,
그 때의 서비스를 제공 받는 집들의 수이다.

운영 비용 = K * K + (K - 1) * (K - 1)

10
8 3
0 0 0 0 0 1 0 0
0 1 0 1 0 0 0 1
0 0 0 0 0 0 0 0
0 0 0 1 0 1 0 0
0 0 1 1 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 1 0 1 0
1 0 0 0 0 0 0 0
#1 5

매 칸마다 해볼건데 종료 조건을 K 값이냐

종료 조건: Map 에 들어있는 1 개수 * M 보다 K 값이 커지면
넘겨줄 값: K를 1씩 올려야겠죠?
범위는 k가 2면 내 좌표 기준 -1 ~ +1 까지 위로도 -1 아래도 1
3이면 -2 ~ +2

0
  0
0 0 0
  0
3
    0     -3+3 ~ 3-2
  0 0 0   -3+2 ~ 3-1
0 0 0 0 0 -3+1 ~ 3
  0 0 0
    0

      0
    0 0 0
  0 0 0 0 0
0 0 0 0 0 0 0
  0 0 0 0 0
    0 0 0
      0