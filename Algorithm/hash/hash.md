# 해시
데이터의 양이 매우 클 때를 해결하기 위해 데이터를 고정된 크기의 값으로 변환하는 과정
해시값(Hash Value)는 원본 데이터를 고유하게 식별하거나 데이터를 빠르게 검색하는데 사용
- 특징:
    - 빠른 데이터 검색: 키를 통해 데이터에 직접 접근할 수 있어서 검색이 빠름(O(1))
    - 데이터 무결성 검증: 작은 변화에도 해시값이 크게 달라지는 특성을 활용해 변조 여부를 확인할 수 있음
    - 암호화: 원본 대신 해시값을 저장해 보안을 강화(단방향 변환으로, 해시값에서 원본을 유추하기 어려움)
    - 중복 제거: 동일한 데이터는 같은 해시값을 가지므로 중복을 쉽게 식별할 수 있음(ex: 라빈-카프 알고리즘)
    - 해시 충돌: 서로 다른 입력값이 동일한 해시값을 생성할 수 있음
    - 메모리 사용량: 해시 테이블은 배열보다 더 많은 메모리를 차지하며, 충돌 해결을 위한 추가 공간이 필요
    - 순서 보존 불가: 해시 함수는 입력 데이터의 순서를 보존하지 않으며, 정렬된 데이터가 필요한 경우에는 적합X(예외: python-dict)
## 해시 함수
- 입력값을 고정된 크기의 해시 값으로 변환하는 함수
    - 좋은 해시 함수:
        - 결정론적 특성: 동일한 입력은 항상 동일한 해시값을 생성
        - 균등한 분포: 해시 값이 균등하게 분포되어야 좋은 해시 함수
        - 충돌 최소화: 다른 입력값이 동일한 해시값을 생성하는 경우가 낮아야 좋은 해시함수
        - 눈사태 효과: 입력의 작은 변화가 출력의 큰 변화를 야기해야 함(유사한 입력들이 다른 해시 값을 가지게 하여 클러스터링 방지)
        - 효율성: 계산 속도가 빨라야 함
        - 저항성: 입력값을 예상하기 어려워야 함
    - 나머지 연산 해시 함수(Division Hash Function):
        - 가장 기본적인 해시 함수
        - 키(key)를 해시 테이블의 크기로 나눈 나머지를 해시 값을 사용
        - 구현이 매우 간단하고, 이해하기 쉬움
        - 계산 속도가 빠름(효율성)
        - h(k) = k mod m(k = 해시할 키 값, m = 해시 테이블 크기)
        - 장점:
            - 정수 키에 대해 효과적으로 작동
            - 해시 테이블의 크기를 적절히 선택하면 좋은 성능을 발휘
        - 단점:
            - 테이블 크기 선택(중요, 소수/ 2의 거듭제곱)에 민감
            - 특정 패턴의 키에 대해 성능이 저하될 수 있음
            - 문자열이나 복잡한 키는 추가적인 처리가 필요함
        - 보조 해시(해시 값에 해시 한번 더) 사용, MAD(Multiply-Add-divide)등을 사용해 성능 개선 가능
    - 곱셈 해시 함수(Multiplication Hash Function):
        - 나머지 연산 해시 함수보다 더 균일한 분포를 제공
        - 키를 0과 1사이의 실수로 변환, 이를 해시 테이블의 크기와 곱해 해시 값을 생성
        - 해시 테이블의 크기에 덜 민감함
        - h(k)=m(kA mod 1) (k=해시할 키 값, m=해시 테이블 크기, A=0과 1 사이의 실수)
        - A 값의 선택(중요)이 성능에 큰 영향을 미침
        - 장점:
            - 키의 분포에 덜 민감
            - 나머지 연산 해시 함수에 비해 더 균일한 분포를 제공
        - 단점:
            - 구현이 조금 더 복잡
            - 부동 소수점 연산을 사용해 정밀도 문제가 발생할 수 있음
        - 비트 연산, 다양한 A값으로 실험하기 등으로 성능 개선 가능
    - 폴딩 해시 함수(Folding Hash Function, 거의 사용 안함):
        - 키를 여러 부분으로 나누고, 이 부분들을 조합해 최종 해시 값을 생성
        - 주로 긴 숫자나 문자열 키에 사용
        - 작동 원리
            1. 키를 일정 크기의 부분으로 나눈다(ex: 2자리 or 3자리)
            2. 나눈 부분들을 모두 더한다.
            3. 최종 합을 해시 테이블 크기로 나눈 나머지를 해시 값으로 사용
        - 키의 모든 부분을 사용해 비교적 균일한 분포를 보임, 폴딩 크기를 조절해 다양하게 사용 가능
        - 장점:
            - 긴 키나 문자에 효과적
            - 키의 모든 부분을 사용해 비교적 균일한 분포를 보임
            - 구현이 간단
        - 단점:
            - 짧은 키에 대해서는 오버헤드가 있을 수 있음
            - 폴딩 크기가 성능에 영향을 미침
        - 가중치 부여, 덧셈 대신 다른 방식(XOR), 순환 시프르 등의 방법으로 성능 개선 가능
    - 다항식 해시 함수(Polynomial Hash Function):
        - 문자열을 다항식으로 표현해 해시 값을 계산
        - 문자열 처리에 유용
        - h(s)=(s[0]*p0+s[1]*p1+...+s[n-1]*p(n-1)) mod m
        (s=해시할 문자열, p=기수(base, 일반적으로 소수), m=큰 소수 값)
        - 적절한 p와 m을 선택하면 균일한 해시 분포를 얻을 수 있음
        - 문자열의 순서가 해시 값에 영향을 미침
        - 장점:
            - 문자열 비교에 효과적
            - 문자열 패턴 매칭 알고리즘에 유용(라빈-카프)
            - 간단하면서도 효과적인 해시 분포 제공
        - 단점:
            - 긴 문자열에 대해서는 오버 플로우가 있을 수 있음
            - p와 m 값의 선택이 성능에 큰 영향을 미침
        - 라빈-카프 알고리즘, 데이터베이스 인덱싱 등 다양한 분야에서 활용
    - SHA - 256
        - 임의의 길이의 입력 데이터를 고정된 크기의 256비트(32바이트) 해시 값으로 변환하는 함수
        - 현대적이고 널리 사용되는 암호학적 해시 함수
        - 입력 크기에 관계없이 항상 256비트 해시 값을 생성
        - 해시 값에서 원본 메시지를 복원하는 것이 실질적으로 불가능(단방향)
        - 입력의 작은 변화가 출력의 큰 변화를 야기함(스노우볼)
        - 같은 해시 값을 가진 두 개의 다른 입력을 찾기가 매우 어려움(저항성)

## 해시 테이블
- 해시 값을 인덱스로 사용하여 데이터를 저장하고 검색하는 자료구조
- 대부분의 경우 상수 시간(O(1)) 내에 데이터 검색/삽입/삭제
- 캐싱 보안 등 다양하게 응용
- 해시 함수의 성능에 큰 영향 > 충돌 처리 필요(Chaining, Open Addressoing)

